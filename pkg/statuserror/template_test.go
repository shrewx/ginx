package statuserror

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestStatusErrorTemplate_Content(t *testing.T) {
	// Test that the template contains expected content
	assert.Contains(t, StatusErrorTemplate, "Code generated by tools. DO NOT EDIT!")
	assert.Contains(t, StatusErrorTemplate, "package {{ .Package }}")
	assert.Contains(t, StatusErrorTemplate, "github.com/shrewx/ginx/pkg/statuserror")
	assert.Contains(t, StatusErrorTemplate, "github.com/nicksnyder/go-i18n/v2/i18n")
	assert.Contains(t, StatusErrorTemplate, "func init()")
	assert.Contains(t, StatusErrorTemplate, "i18nx.RegisterHooks(RegisterErrorMessages)")
}

func TestStatusErrorTemplate_Methods(t *testing.T) {
	// Test that the template contains all expected methods
	expectedMethods := []string{
		"WithParams",
		"WithField",
		"Localize",
		"LocalizeValue",
		"LocalizeData",
		"StatusCode",
		"Key",
		"Prefix",
		"ID",
		"Code",
		"Error",
		"Value",
	}

	for _, method := range expectedMethods {
		assert.Contains(t, StatusErrorTemplate, "func (v {{ .ClassName }}) "+method)
	}
}

func TestStatusErrorTemplate_KeyFunction(t *testing.T) {
	// Test that the Key function template is correct
	assert.Contains(t, StatusErrorTemplate, "func (v {{ .ClassName }}) Key() string {")
	assert.Contains(t, StatusErrorTemplate, "switch v {")
	assert.Contains(t, StatusErrorTemplate, "{{range .Errors}}")
	assert.Contains(t, StatusErrorTemplate, "case {{ .Key}}:")
	assert.Contains(t, StatusErrorTemplate, "return \"{{ .Key}}\"")
	assert.Contains(t, StatusErrorTemplate, "{{end}}")
	assert.Contains(t, StatusErrorTemplate, "return \"UNKNOWN\"")
}

func TestStatusErrorTemplate_PrefixFunction(t *testing.T) {
	// Test that the Prefix function template is correct
	assert.Contains(t, StatusErrorTemplate, "func (v {{ .ClassName }}) Prefix() string {")
	assert.Contains(t, StatusErrorTemplate, "return \"{{ .Prefix }}\"")
}

func TestStatusErrorTemplate_IDFunction(t *testing.T) {
	// Test that the ID function template is correct
	assert.Contains(t, StatusErrorTemplate, "func (v {{ .ClassName }}) ID() string {")
	assert.Contains(t, StatusErrorTemplate, "if v.Prefix() == \"\" {")
	assert.Contains(t, StatusErrorTemplate, "return strconv.FormatInt(int64(v.Code()), 10)")
	assert.Contains(t, StatusErrorTemplate, "return v.Prefix() + \".\" + strconv.FormatInt(int64(v.Code()), 10)")
}

func TestStatusErrorTemplate_CodeFunction(t *testing.T) {
	// Test that the Code function template is correct
	assert.Contains(t, StatusErrorTemplate, "func (v {{ .ClassName }}) Code() int64 {")
	assert.Contains(t, StatusErrorTemplate, "return int64(v)")
}

func TestStatusErrorTemplate_ErrorFunction(t *testing.T) {
	// Test that the Error function template is correct
	assert.Contains(t, StatusErrorTemplate, "func (v {{ .ClassName }}) Error() string {")
	assert.Contains(t, StatusErrorTemplate, "return statuserror.NewStatusErr(v.Key(), v.Code()).Error()")
}

func TestStatusErrorTemplate_ValueFunction(t *testing.T) {
	// Test that the Value function template is correct
	assert.Contains(t, StatusErrorTemplate, "func (v {{ .ClassName }}) Value() string {")
	assert.Contains(t, StatusErrorTemplate, "return statuserror.NewStatusErr(v.Key(), v.Code()).Value()")
}

func TestStatusErrorTemplate_MapFunction(t *testing.T) {
	// Test that the map generation function is present
	assert.Contains(t, StatusErrorTemplate, "func Get{{ .ClassName }}Map() map[string]map[{{ .ClassName }}]string")
	assert.Contains(t, StatusErrorTemplate, "return map[string]map[{{ .ClassName }}]string{")
	assert.Contains(t, StatusErrorTemplate, "{{range $lang, $error := .Messages}}")
	assert.Contains(t, StatusErrorTemplate, "\"{{$lang}}\": {")
	assert.Contains(t, StatusErrorTemplate, "{{range $error}}{{.K}}: \"{{.Message}}\",")
}

func TestStatusErrorTemplate_RegisterFunction(t *testing.T) {
	// Test that the register function is present
	assert.Contains(t, StatusErrorTemplate, "func RegisterErrorMessages() {")
	assert.Contains(t, StatusErrorTemplate, "errorMap := Get{{ .ClassName }}Map()")
	assert.Contains(t, StatusErrorTemplate, "for lang, messages := range errorMap {")
	assert.Contains(t, StatusErrorTemplate, "var i18nMessages []*i18n.Message")
	assert.Contains(t, StatusErrorTemplate, "for key, message := range messages {")
	assert.Contains(t, StatusErrorTemplate, "i18nMessages = append(i18nMessages, &i18n.Message{ID: fmt.Sprintf(\"%s.%s\", lang, key.ID()), Other: message})")
	assert.Contains(t, StatusErrorTemplate, "i18nx.AddMessages(lang, i18nMessages)")
}

func TestStatusErrorTemplate_Imports(t *testing.T) {
	// Test that all required imports are present
	expectedImports := []string{
		"fmt",
		"github.com/shrewx/ginx/pkg/i18nx",
		"github.com/shrewx/ginx/pkg/statuserror",
		"github.com/nicksnyder/go-i18n/v2/i18n",
	}

	for _, imp := range expectedImports {
		assert.Contains(t, StatusErrorTemplate, imp)
	}
}

func TestStatusErrorTemplate_Structure(t *testing.T) {
	// Test that the template has proper structure
	lines := strings.Split(StatusErrorTemplate, "\n")

	// Should have package declaration
	assert.True(t, strings.HasPrefix(lines[0], "// Code generated"))
	assert.True(t, strings.Contains(lines[1], "package {{ .Package }}"))

	// Should have import block
	importStart := -1
	importEnd := -1
	for i, line := range lines {
		if strings.Contains(line, "import (") {
			importStart = i
		}
		if importStart != -1 && strings.Contains(line, ")") && importEnd == -1 {
			importEnd = i
			break
		}
	}
	assert.True(t, importStart != -1, "Import block should be present")
	assert.True(t, importEnd != -1, "Import block should be closed")

	// Should have init function
	hasInit := false
	for _, line := range lines {
		if strings.Contains(line, "func init()") {
			hasInit = true
			break
		}
	}
	assert.True(t, hasInit, "Init function should be present")
}
